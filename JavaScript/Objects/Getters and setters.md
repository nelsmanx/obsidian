Есть два типа свойств объекта:
 - **свойства-данные** (`data properties`);
 - **свойства-аксессоры** (`accessor properties`). 

Свойства-аксессоры представлены методами: «геттер» – для чтения и «сеттер» – для записи. При литеральном объявлении объекта они обозначаются `get` и `set`.

> [!warning] `set` - функция, которая принимает только один аргумент

 Геттеры/сеттеры можно использовать как обёртки над «реальными» значениями свойств, чтобы получить больше контроля над операциями с ними. По своей сути это функции, которые используются для присвоения и получения значения, но во внешнем коде они выглядят как обычные свойства объекта. В этом и заключается смысл свойств-аксессоров. Мы не _вызываем_ `user.name` как функцию ( `user.name()`), а _читаем_ как обычное свойство: геттер выполнит всю работу за кулисами. То же самое касается сеттера.

## Возможности

Геттеры и сеттеры дают возможность: 

1. **Валидация данных** (проверка ввода).
2. **Динамические вычисления** (например, `area = width * height`).
3. **Логирование изменений** (отслеживание значений).
4. **Инкапсуляция** (скрытие внутренней логики).
5. **Гибкость** (можно менять логику без изменения интерфейса).

### 1. Валидация и защита данных

Сеттер позволяет проверять значение перед записью в свойство.

```js
const user = {
  _age: 0,  // условно приватное поле

  get age() {
    return this._age;
  },

  set age(value) {
    if (value >= 0 && value <= 120) {
      this._age = value;
    } else {
      console.error("Недопустимый возраст!");
    }
  }
};

user.age = 25;  // OK
user.age = -10; // Ошибка: "Недопустимый возраст!"
```

✅ **Плюс:** данные всегда корректны, нельзя записать `NaN`, `undefined` или отрицательные числа.
___

### 2. Вычисляемые свойства + свойства только для чтения

Геттер может динамически вычислять значение на основе других полей. При этом нам нужно, чтобы значение нельзя было установить вручную.  Для этого нам нужно создать только геттер, но не сеттер.

```js
const rectangle = {
  width: 10,
  height: 5,

  get area() {
    return this.width * this.height;
  }
};

console.log(rectangle.area); // 50 (вычисляется при каждом обращении)
rectangle.area = 50 // Error (no setter)
```

✅ **Плюс:** не нужно хранить лишние данные, значение всегда актуально.
___

### 3. Логирование и отладка

Можно добавить `console.log` в геттер/сеттер, чтобы отслеживать изменения.

```js
const product = {
  _price: 0,

  get price() {
    console.log("Цена запрошена");
    return this._price;
  },

  set price(value) {
    console.log(`Цена изменена: ${value}`);
    this._price = value;
  }
};

product.price = 100; // "Цена изменена: 100"
console.log(product.price); // "Цена запрошена" → 100
```

✅ **Плюс:** удобно для отладки сложных объектов.
___

### 4. Сокрытие внутренней логики (инкапсуляция)

Геттеры/сеттеры позволяют скрыть способ хранения данных.

```js
class User {
  constructor(name) {
    this._name = name;  // "приватное" поле
  }

  get name() {
    return this._name.toUpperCase();
  }

  set name(value) {
    this._name = value.trim();
  }
}

const user = new User(" Alice ");
console.log(user.name); // "ALICE" (геттер форматирует)
user.name = "  Bob  ";  // сеттер очищает пробелы
```

✅ **Плюс:** внешний код работает с `name`, но не знает про `_name`.
___

### 5. Совместимость и обратная совместимость

Если раньше свойство было обычным (`value`), а потом стало вычисляемым, геттер/сеттер позволяет сохранить интерфейс.

```js
// Раньше:
const obj = {
  value: 100
};

// Теперь:
const obj = {
  _value: 100,

  get value() {
    return this._value * 2;
  },

  set value(v) {
    this._value = v / 2;
  }
};

console.log(obj.value); // 200 (геттер умножает на 2)
```

✅ **Плюс:** код, использующий `obj.value`, не сломается.
___

## Когда НЕ нужны геттеры/сеттеры?

❌ Если свойство просто хранит значение без логики.  
❌ Если не нужна валидация, вычисления или логирование.

Плохой пример:

```js
// Избыточно:
const point = {
  _x: 0,
  _y: 0,

  get x() { return this._x; },
  set x(v) { this._x = v; },

  get y() { return this._y; },
  set y(v) { this._y = v; }
};

// Лучше просто:
const point = { x: 0, y: 0 };
```