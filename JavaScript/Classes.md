В JavaScript классы, появившиеся в ES6, представляют собой синтаксический сахар над прототипным наследованием, позволяя более удобный способ создания объектов и организации кода. Они определяют структуру объекта, включая его свойства и методы, и служат шаблоном для создания экземпляров этого объекта.

Классы объявляются через ключевое слово `class`, за которым следует имя класса (с большой буквы) и тело класса. Тело класса — это фигурные скобки, внутри которых определяются конструктор, свойства и методы класса.

Для создания нового объекта используется `new Person()` со всеми перечисленными методами.

```js
class Person {
  constructor(name, age) {
    this.name = name;
  }

  greet() {
    console.log(`Привет, я ${this.name}!`);
  }
}

const person = new Person("Иван");
person.greet(); // "Привет, я Иван!"
```

Метод `constructor` - специальный метод, необходимый для создания и инициализации объектов, созданных, с помощью класса. В классе может быть только один метод с именем `constructor`.


В JavaScript класс – это разновидность функции.

```js
alert (typeof Person) // function
```

Вот что на самом деле делает конструкция `class Person {...}`:

1. Создаёт функцию с именем `Person`, которая становится результатом объявления класса. Код функции берётся из метода `constructor` (она будет пустой, если такого метода нет).
2. Сохраняет все методы, такие как `greet`, в `User.prototype`.

При вызове метода объекта `new Person` он будет взят из прототипа. Таким образом, объекты `new Person` имеют доступ к методам класса.

На картинке показан результат объявления `class Person`:

![[Pasted image 20250713123532.png]]
___

## Class Expression

Можно также объявить класс через с помощью `Class Expression`:

```js
let Person = class { } // Class Expression (по аналогии с Function Expression):
```

Аналогично `Named Function Expression`, может иметь имя, видное только внутри класса.

```js
let User = class MyClass {
  sayHi() {
    alert(MyClass); // имя MyClass видно только внутри класса
  }
};

new User().sayHi(); // работает, выводит определение MyClass
alert(MyClass); // ошибка, имя MyClass не видно за пределами класса
```
___

## Подъем (hoisting)

Объявление класса отличается от объявления функции тем, что объявление класса не поднимается (`hoisted`) в начало области видимости, в которой оно находится. Это означает, что нельзя использовать класс до того, как он будет определен. Если попытаться сделать это, будет выброшена ошибка `ReferenceError`.
___

## Геттеры/сеттеры

Есть два типа свойств объекта. Первый тип это **свойства-данные** (`data properties`).
Второй тип свойств - это **свойства-аксессоры** (`accessor properties`). По своей сути это функции, которые используются для присвоения и получения значения, но во внешнем коде они выглядят как обычные свойства объекта.

Свойства-аксессоры представлены методами: «геттер» – для чтения и «сеттер» – для записи. При литеральном объявлении объекта они обозначаются `get` и `set`.

Как и в литеральных объектах, в классах можно объявлять вычисляемые свойства, геттеры/сеттеры и т.д.

Снаружи свойство-аксессор выглядит как обычное свойство. В этом и заключается смысл свойств-аксессоров. Мы не _вызываем_ `user.name` как функцию, а _читаем_ как обычное свойство: геттер выполнит всю работу за кулисами. То же самое касается сеттера.

Геттеры/сеттеры можно использовать как обёртки над «реальными» значениями свойств, чтобы получить больше контроля над операциями с ними.

Например, если мы хотим запретить устанавливать короткое имя для `user`, мы можем использовать сеттер `name` для проверки, а само значение хранить в отдельном [[#Приватные и защищённые методы и свойства |защищенном свойстве]] `_name`:

```js
class User {
  constructor(name) {
    this.name = name; // вызывает сеттер
  }

  get name() {
    return this._name;
  }

  set name(value) {
    if (value.length < 4) {
      alert("Имя слишком короткое.");
      return;
    }
    this._name = value;
  }
}
  
let user = new User("Иван");
alert(user.name); // Иван

user = new User(""); // Имя слишком короткое.
```

Таким образом, само имя хранится в `_name`, доступ к которому производится через геттер и сеттер.

Технически, внешний код всё ещё может получить доступ к имени напрямую с помощью `user._name`, но существует широко известное соглашение о том, что свойства, которые начинаются с символа `"_"`, являются внутренними, и к ним не следует обращаться из-за пределов объекта.
___

## Свойства классов

> [!NOTE] Старым браузерам может понадобиться полифил
> Свойства классов добавлены в язык недавно (ES2022)

В приведённом выше примере у класса `User` были только методы. Можно добавить свойство:

```js
class User {
  name = "Аноним";
  sayHi() {
    alert(`Привет, ${this.name}!`);
  }
}

new User().sayHi();
```

> [!warning] Свойство `name` не устанавливается в `User.prototype`. 

Вместо этого оно создаётся оператором `new` перед запуском конструктора, это именно свойство объекта.

```js
class Animal {
  constructor(name) {
    this.speed = 0;  // speed инициализируется в конструкторе
    this.name = name;
  }
}

class Animal {
  speed = 0;  // speed инициализируется как поле класса (ES2022+)

  constructor(name) {
    this.name = name;
  }
}
```

`this.speed = 0` **в конструкторе** — классический подход, работает везде.
`speed = 0` **в теле класса** — современный синтаксис, удобен для:
- явного объявления полей (лучшая читаемость),
- использования приватных полей (`#speed`),
- статических полей (`static speed = 10`).

Свойство `speed` будет **собственным свойством экземпляра** (не в прототипе).

Оба варианта делают одно и то же, но второй (`speed = 0`) — более современный и мощный. Используйте его, если поддерживаете ES2022+.
___

## Наследование классов

Наследование классов – это способ расширения одного класса другим классом. Таким образом, мы можем добавить новый функционал к уже существующему.

Синтаксис для расширения другого класса следующий: `class Child extends Parent { }`.

```js
class Animal {
  constructor(name) {
    this.name = name;
  }
  run() {
    alert(`${this.name} бежит.`);
  }
  stop() {
    alert(`${this.name} стоит неподвижно.`);
  }
}

class Rabbit extends Animal {
  hide() {
    alert(`${this.name} прячется.`);
  }
}

let rabbit = new Rabbit("Белый кролик");

rabbit.run(); // Белый кролик бежит.
rabbit.hide(); // Белый кролик прячется.
```

Объект класса `Rabbit` имеет доступ как к методам `Rabbit`, таким как `rabbit.hide()`, так и к методам `Animal`, таким как `rabbit.run()`.

Внутри ключевое слово `extends` работает по старой доброй механике прототипов. Оно устанавливает `Rabbit.prototype.[[Prototype]]` в `Animal.prototype`. Таким образом, если метода не оказалось в `Rabbit.prototype`, JavaScript берет его из `Animal.prototype`.

![[Pasted image 20250713154321.png]]

Например, чтобы найти метод `rabbit.run`, движок проверяет (снизу вверх на картинке):
1. Объект `rabbit` (не имеет `run`).
2. Его прототип, то есть `Rabbit.prototype` (имеет `hide`, но не имеет `run`).
3. Его прототип, то есть (вследствие `extends`) `Animal.prototype`, в котором, наконец, есть метод `run`.


### Переопределение конструктора (`super()`)

У `Rabbit` нет своего конструктора. Согласно спецификации если класс расширяет другой класс и не имеет конструктора, то автоматически создаётся такой «пустой» конструктор:

```js
class Rabbit extends Animal {
  // генерируется для классов-потомков, у которых нет своего конструктора
  constructor(...args) {
    super(...args);
  }
}
```

> Если необходимо добавить дополнительные свойства в класс-наследник, необходимо в конструкторе наследуемого класса  вызывать `super(...)`, и (!) сделать это перед использованием `this`.

```js
class Rabbit extends Animal {
  constructor(name, earLength) {
    super(name); // перед использованием this
    this.earLength = earLength;
  }
}
```

Если в дочернем классе есть `constructor`, но нет `super()`, будет ошибка:

```js
class Rabbit extends Animal {
  constructor(name, earLength) {
	this.name = name; 
    this.earLength = earLength; 
  }

  // или только earLength
  constructor(name, earLength) { 
    this.earLength = earLength; 
  }
}

const rabbit = new Rabbit("Белый кролик", 10); // ❌ ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor
```

Ошибка возникает потому, что 
- Когда выполняется обычный конструктор, он создаёт пустой объект и присваивает его `this`.
- Когда запускается конструктор унаследованного класса, он этого не делает. Вместо этого он ждёт, что это сделает конструктор родительского класса.

Поэтому, если мы создаём собственный конструктор, мы должны вызвать `super`, в противном случае объект для `this` не будет создан, и мы получим ошибку.

Чтобы конструктор `Rabbit` работал, он должен вызвать `super()` до того, как использовать `this`, чтобы не было ошибки.


### Переопределение  методов (`super()`)

Можно переопределять методы в наследуемом классе:

```js
class Animal {
  // ... constructor() {}
  stop() {
    alert(`${this.name} стоит неподвижно.`);
  }
}

class Rabbit extends Animal {
  stop() {
    // теперь это будет использоваться для rabbit.stop()
    // вместо stop() из класса Animal
  }
}
```

Для того, чтобы не полностью заменить родительский метод, а сделать новый на его снове, можно сначала вызвать родительский метод, а затем расширить его функциональность. Для вызова родительского метода используется `super.method()`

```js
class Rabbit extends Animal {
   hide() {
    alert(`${this.name} прячется.`);
  }
  
  stop() {
    super.stop(); // вызываем родительский метод stop
    this.hide(); // и затем hide
  }
}
```


> [!warning] У стрелочных функций нет `super`
> При обращении к `super` стрелочной функции он берётся из внешней функции

```js
class Rabbit extends Animal {
  stop() {
    setTimeout(() => super.stop(), 1000); // вызывает родительский stop после 1 секунды
  }
}
```

В примере `super` в стрелочной функции тот же самый, что и в `stop()`, поэтому метод отрабатывает как и ожидается. Если бы мы указали здесь «обычную» функцию, была бы ошибка:

```js
setTimeout(function() { super.stop() }, 1000); // Unexpected super
```
___

## Статические свойства и методы

> [!NOTE] **Статические свойства классов (Static Class Fields) были добавлены в ES2022**
> В то время как статические методы были реализованы с самого начала классов ES6

Статические методы используются для функциональности, принадлежат самому классу «в целом», а не относятся к конкретному объекту класса. В объявление класса они добавляются с помощью ключевого слова `static`. 
Пример утилитарой функции:

```js
class DateUtils {
  static MONTHS = ['Январь', 'Февраль', 'Март', '...'];

  static getCurrentMonth() {  
    const monthIndex = new Date().getMonth();
    return this.MONTHS[monthIndex];
  }
}

console.log(DateUtils.getCurrentMonth()); // "Июль" (текущий месяц)
```

Значением `this` при вызове `DateUtils.getCurrentMonth()` является сам конструктор класса `DateUtils` (правило «объект до точки»).

Технически, статическое объявление – это то же самое, что и присвоение классу:

```js
DateUtils.property = ...
DateUtils.method = ...
```

Другим примером может быть так называемый «фабричный» метод (создание объектов с усложненной логикой):

```js
class User {
  constructor(name, email) {
    this.name = name;
    this.email = email;
  }

  static createAdmin(email) {
    return new User('Admin', email);
  }

  static isValidEmail(email) {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  }
}

const admin = User.createAdmin('admin@example.com');
console.log(admin.name); // "Admin"

console.log(User.isValidEmail('test@mail')); // false
```

> [!WARNING] Статические методы недоступны для отдельных объектов
> Статические методы могут вызываться для классов, но не для отдельных объектов.

Например. такой код с использованием класса `User` не будет работать:

```js
const user = new User('Mike');
console.log(user.isValidEmail('test@mail')); // Error: user.isValidEmail is not a function
```


> [!tip] Статические свойства и методы наследуются.
> Для `class B extends A` прототип класса `B` указывает на `A`: `B.[[Prototype]] = A`. Таким образом, если поле не найдено в `B`, поиск продолжается в `A`.

___

## Приватные и защищённые методы и свойства

В объектно-ориентированном программировании свойства и методы разделены на 2 группы:
- _Внутренний интерфейс_ – методы и свойства, доступные из других методов класса, но не снаружи класса.
- _Внешний интерфейс_ – методы и свойства, доступные снаружи класса.

В JavaScript есть два типа полей (свойств и методов) объекта:
- Публичные: доступны отовсюду. Они составляют внешний интерфейс. До этого момента мы использовали только публичные свойства и методы.
- Приватные: доступны только внутри класса. Они для внутреннего интерфейса.

### Защищенные свойства

Во многих других языках также существуют «защищённые» поля, доступные только внутри класса или для дочерних классов (то есть, как приватные, но разрешён доступ для наследующих классов) и также полезны для внутреннего интерфейса. В некотором смысле они более распространены, чем приватные, потому что мы обычно хотим, чтобы наследующие классы получали доступ к внутренним полям.

Защищённые поля **не реализованы в JavaScript на уровне языка**, но на практике они очень удобны, поэтому их эмулируют.

Защищённые свойства обычно начинаются с префикса `_`. 
Это не синтаксис языка: есть хорошо известное соглашение между программистами, что такие свойства и методы не должны быть доступны извне. Большинство программистов следуют этому соглашению.

В приведенном ниже примере свойство `waterAmount` изменено на защищённое, чтобы иметь больше контроля над ним. Например, мы не хотим, чтобы кто-либо устанавливал его ниже нуля.

```js
class CoffeeMachine {
  _waterAmount = 0;

  set waterAmount(value) {
    if (value < 0) throw new Error("Отрицательное количество воды");
    this._waterAmount = value;

  }
  
  get waterAmount() {
    return this._waterAmount;
  }

  constructor(power) {
    this._power = power;
  }
}

const coffeeMachine = new CoffeeMachine(100);

// устанавливаем количество воды
coffeeMachine.waterAmount = -10; // Error: Отрицательное количество воды
```

### Свойства только для чтения

Иногда нужно, чтобы свойство устанавливалось только при создании объекта и после этого никогда не изменялось. 

Это как раз требуется для кофеварки: мощность никогда не меняется.  Сделаем свойство `power` доступным только для чтения.

Для этого нам нужно создать только геттер, но не сеттер:

```js
class CoffeeMachine {
  // ...

  constructor(power) {
    this._power = power;
  }

  get power() {
    return this._power;
  }
}

let coffeeMachine = new CoffeeMachine(100);

alert(`Мощность: ${coffeeMachine.power}W`); // Мощность: 100W

coffeeMachine.power = 25; // Error (no setter)
```

> [!warning] Защищённые поля наследуются
> Если мы унаследуем `class MegaMachine extends CoffeeMachine`, ничто не помешает нам обращаться к `this._waterAmount` или `this._power` из методов нового класса.
> 
> Таким образом, защищённые поля наследуются в отличие от приватных полей

### Приватные свойства и методы `#` 

> [!NOTE] **Приватные свойства классов были добавлены в ES2022**

Приватные свойства и методы должны начинаться с `#`. Они доступны только внутри класса.

Например, в классе ниже есть приватное свойство `#waterLimit` и приватный метод `#checkWater` для проверки количества воды:

```js
class CoffeeMachine {
  #waterLimit = 200;

  #checkWater(value) {
    if (value < 0) throw new Error("Отрицательный уровень воды");
    if (value > this.#waterLimit) throw new Error("Слишком много воды");
  }
}

let coffeeMachine = new CoffeeMachine();

// снаружи нет доступа к приватным методам класса
coffeeMachine.#checkWater(); // Error
coffeeMachine.#waterLimit = 1000; // Error
```

В отличие от защищённых, функциональность приватных полей обеспечивается самим языком. 

Но если мы унаследуем от `CoffeeMachine`, то мы не получим прямого доступа к `#waterAmount`. Мы будем вынуждены полагаться на геттер/сеттер `waterAmount`:

```js
class MegaCoffeeMachine extends CoffeeMachine {
  method() {
    alert( this.#waterAmount ); // Error: can only access from CoffeeMachine
  }
}
```

Во многих случаях такое ограничение слишком жёсткое. Раз уж мы расширяем `CoffeeMachine`, у нас может быть вполне законная причина для доступа к внутренним методам и свойствам. Поэтому защищённые свойства используются чаще, хоть они и не поддерживаются синтаксисом языка.

![[Приватные и защищённые методы и свойства - Learn.JavaScript.ru.mhtml]]
___

## Проверка класса `instanceof`

```js
obj instanceof Class
```

Оператор `instanceof` позволяет проверить, принадлежит ли объект указанному классу, с учётом наследования. Оператор вернёт `true`, если `obj` принадлежит классу `Class` или наследующему от него.
Например: 

```js
class Rabbit {}
let rabbit = new Rabbit();

alert( rabbit instanceof Rabbit ); // true
```

Также это работает с функциями-конструкторами и для встроенных классов, таких как `Array`:

```js
function Rabbit() {}
alert( new Rabbit() instanceof Rabbit ); // true

const arr = [1, 2, 3];
alert( arr instanceof Array ); // true
alert( arr instanceof Object ); // true
```

 `arr` также принадлежит классу `Object`, потому что `Array` наследует от `Object`.



