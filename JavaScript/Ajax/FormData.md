`FormData` — это специальная коллекция данных, которая позволяет передавать данные в виде пар `[ключ, значение]` на сервер.  Создается с помощью конструктора:

```js
const formData = new FormData([form]);
```

Если передать в конструктор элемент HTML-формы `form`, то создаваемый объект автоматически прочитает из неё поля.

Его особенность заключается в том, что методы для работы с сетью, например `fetch`, позволяют указать объект `FormData` в свойстве тела запроса `body`.

Он будет соответствующим образом закодирован и отправлен с заголовком `Content-Type: multipart/form-data`.

То есть, для сервера это выглядит как обычная отправка формы,  поэтому, значения в `FormData`, как и у обычной HTML формы, могут быть только строками или файлами.  Все данные других типов будут преобразованы в строку. Например, число `30` будет преобразовано в стороку `'30'`.

Сильной стороной `FormData` является загрузка файлов на сервер. Если при использовании `'application/json'` файлы необходимо дополнительно кодировать каким-то способом, чтобы привести к строке (и точно так же декодировать на сервере), то `FormData` умеет это делать «из коробки».

> ВАЖНО: у каждого `input` должен быть аттрибут `name`
___

### Отправка простой формы

```html
<form>
	<input type="text" name="title" placeholder="title" />
	<input type="text" name="body" placeholder="body" />
	<button>Create new post</button>
</form>
```

```js
const form = document.querySelector('form');
const formData = new FormData(form);

form.addEventListener('submit', async (e) => {
	event.preventDefault();
	const response = await fetch('https://jsonplaceholder.typicode.com/posts', {
		method: 'POST',
		body: formData
	});
	const result = await response.json();
	console.log(result);
})
```
___

### Методы объекта FormData

Основные методы для работы с `FormData`:
- `append(ключ, значение)` — добавляет значение для ключа с сохранением предыдущих значений.
	Технически форма может иметь много полей с одним и тем же именем `name`, поэтому несколько вызовов `append` добавят несколько полей с одинаковыми именами.
- `set(ключ, значение)` — устанавливает значение для ключа, перезаписывая предыдущие значения.
	Отличие от `append` в том, что `set` удаляет все уже имеющиеся поля с именем `name` и только затем добавляет новое. То есть этот метод гарантирует, что будет существовать только одно поле с именем `name`
- `get(ключ)` — возвращает первое значение ключа;
- `getAll(ключ)` — возвращает все значения ключа;
- `has(ключ)` — проверяет наличие переданного ключа;
- `entries()` — возвращает [итератор](https://doka.guide/js/iterator/) пар `[ключ, значение]`;
- `values()` — возвращает [итератор](https://doka.guide/js/iterator/) всех значений коллекции;
- `keys()` — возвращает [итератор](https://doka.guide/js/iterator/) всех ключей коллекции;
- `delete(ключ)` — удаляет конкретное значение;

Также можно получить все `entries`, `keys`, и `values`.

```js
const entries = [...formData.entries()];
const values = [...formData.values()];
const keys = [...formData.keys()];
```

---

### Итерация по значениям FormData

`FormData` предоставляет встроенный [итератор](https://doka.guide/js/iterator/) для обхода значений:

```js
const data = new FormData('form')

for (let [key, value] of data) {  // деструктуризация массива
	console.log(`${key} : ${value}`) 
}
```

Тот же итератор доступен при помощи метода `entries()`. Обратите внимание, что каждый элемент итератора — массив из двух элементов. Первый элемент — ключ, а второй — значение.

```js
const data = new FormData('form');

for (let entry of data.entries()) {
	console.log(entry);
}
```

В дополнение к этому, `FormData` предоставляет два других итератора: только ключей при помощи метода `keys()` и только значений при помощи `values()`. Каждый ключ при перечислении ключей появляется ровно столько раз, сколько значений он содержит.

```js
const data = new FormData('form')

for (let value of data.values()) { 
	console.log(value) 
}

for (let key of data.keys()) { 
	console.log(key) 
}
```

___

### Отправка объекта FormData

```js
const formData = new FormData();

formData.append('name', 'Tom');
formData.append('email', 'tom@gmail.com');

const sendData = async () => {
	return await fetch('/api/', {
		method: 'POST',
		body: formData,
	});
};
```

`FormData` является отражением данных обычной HTML-формы с атрибутом `enctype="multipart/form-data"`, поэтому пример выше можно представить следующим образом без JavaScript:

```html
<form
  method="post"
  action="/api/"
  enctype="multipart/form-data"
>
  <input type="text" name="name">
  <input type="email" name="email">
  <button type="submit">Отправить</button>
</form>
```
___

### Способы кодирования данных
 
 Существует несколько популярных способов кодирования данных для отправки на сервер: `'application/x-www-form-urlencoded'`, `'multipart/form-data'` и `'application/json'`. Иногда бывает так, что сервер поддерживает только какой-то определённый способ. Тогда выбирать не приходится. Но, чаще всего, современные решения на бэкенде поддерживают несколько способов, поэтому выбирать нужно в зависимости от задачи.

`'application/x-www-form-urlencoded'` — способ, который используют HTML-формы по умолчанию. Из-за особенностей преобразования, этот способ плохо подходит для больших объёмов данных. В особенности файлов или строк с большим количеством символов не из [ASCII-таблицы](https://ru.wikipedia.org/wiki/ASCII) (например, символы алфавита русского языка).

`'application/json'` — достаточно популярный формат из-за широкого распространения [JSON](https://doka.guide/tools/json/) как формата обмена данными. Из плюсов — поддерживает вложенные структуры, поэтому можно в одном запросе отправить, например, целый объект с данными. Однако, чтобы отправить файл при помощи этого формата, его необходимо дополнительно закодировать в строку каким-нибудь алгоритмом, например, [Base64](https://ru.wikipedia.org/wiki/Base64). Причём на сервере нужно декодировать эти данные обратно.

`'multipart/form-data'` — удобный способ для загрузки файлов, оптимален с точки зрения размера закодированных данных, но в качестве значений может хранить только строки или файлы.

Поэтому лучше всего использовать `FormData` для отправки файлов на сервер, или когда поддержка только строковых данных не является проблемой. Дополнительно, при создании `FormData` можно передать DOM-элемент формы (будет рассмотрено ниже), и коллекция вытащит из этой формы все данные. Поэтому, если стоит задача отправить данные какой-либо формы, `FormData` позволит сделать это с минимумом кода.

Если необходимо передать данные на сервер в формате `json`, то мы мы можем преобразовать `FormData` в объект.

```js
const formDataObject =  Object.fromEntries(formData);
```
---

> При отправке `FormData` в POST-запросе с помощью `XMLHttpRequest` и `fetch` не нужно указывать заголовок `'Content-type':'multpart/form-data'`, так как он создается автоматически
