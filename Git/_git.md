### Выход из режима ожидания ввода 
Нужно нажать клавишу `q` (quit)

## Первоначальная настройка Git

Установка имени пользователя и email
```bash
$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com
```

Проверка установленных имени пользователя и email
```bash
$ git config user.name 
$ git config user.email
```

Чтобы посмотреть все установленные настройки, используйте команду:
```bash
$ git config --list
```
### Инициализация проекта 

```bash
$ cd 'project-folder'
$ git init
```


### Состояния файла

У Git есть три основных состояния, в которых могут находиться ваши файлы: _изменён_ (`modified`), _индексирован_ (`staged`) и _зафиксирован_ (`committed`):

- К изменённым  (`modified`) относятся файлы, которые поменялись, но ещё не были индексированы.
- Индексированный  (`staged`)  - это изменённый файл в его текущей версии, отмеченный для включения в следующий коммит.
- Зафиксированный (`committed`) значит, что файл уже сохранён в вашей локальной базе.

 Три основные секции проекта Git: 
 - рабочий каталог (`working tree`), 
 - область индексирования (`staging area | index`) , 
 - каталог Git (`Git directory)`.
![[Pasted image 20240428200416.png]]
Рабочая копия является снимком одной версии проекта. Эти файлы извлекаются из сжатой базы данных в каталоге Git и помещаются на диск, для того чтобы их можно было использовать или редактировать.

Область индексирования — это файл, обычно находящийся в каталоге Git, в нём содержится информация о том, что попадёт в следующий коммит. Её техническое название на языке Git — «индекс», но фраза «область индексирования» также работает.

Каталог Git — это то место, где Git хранит метаданные и базу объектов вашего проекта. Это самая важная часть Git и это та часть, которая копируется при _клонировании_ репозитория с другого компьютера.

Базовый подход в работе с Git выглядит так:

1. Изменяете файлы вашей рабочей копии.
2. Выборочно добавляете в индекс только те изменения, которые должны попасть в следующий коммит, добавляя тем самым снимки _только_ этих изменений в индекс.
3. Когда вы делаете коммит, используются файлы из индекса как есть, и этот снимок сохраняется в ваш каталог Git.

Если определённая версия файла есть в каталоге Git, эта версия считается _зафиксированной_ (committed). Если файл был изменён и добавлен в индекс, значит, он _индексирован_ (`staged`). И если файл был изменён с момента последнего распаковывания из репозитория, но не был добавлен в индекс, он считается _изменённым_ (`modified`). 

Каждый файл в вашем рабочем каталоге может находиться в одном из двух состояний: 
- под версионным контролем - отслеживаемые (`tracked`),
- под версионным контролем  - неотслеживаемые (`untracked`). 

Отслеживаемые файлы  (`tracked`) - это те файлы, которые были в последнем снимке состояния проекта; они могут быть неизменёнными (`unmodified`), изменёнными (`modified`) или подготовленными к коммиту (`staged`). Если кратко, то отслеживаемые файлы — это те файлы, о которых знает Git.

Неотслеживаемые файлы (`untracked`) - это всё остальное, любые файлы в вашем рабочем каталоге, которые не входили в ваш последний снимок состояния и не подготовлены к коммиту. 


Когда вы впервые клонируете репозиторий, все файлы будут отслеживаемыми и неизменёнными, потому что Git только что их извлек и вы ничего пока не редактировали.

Как только вы отредактируете файлы, Git будет рассматривать их как изменённые (`modified`) , так как вы изменили их с момента последнего коммита. Вы индексируете эти изменения, затем фиксируете все проиндексированные изменения, а затем цикл повторяется.

![[Pasted image 20240428201728.png]]

### Основные команды

Определение состояния файлов
```bash
$ git status
$ git status --short | -s
```

Показать историю коммитов
```bash
$ git log
$ git log --oneline 
```

Добавление новых файлов под версионный контроль или индексация изменений
```bash
$ git add . 
$ git add <file1> <file2>
```

Коммит изменений
```bash
$ git commit -m "Commit message"
```

Коммит изменений всех отслеживаемых (`tracked`) файлов, пропуская этап индексации изменений.
Добавляет только все отслеживаемые файлы. Если файл неотслеживаемый (`untracked`), то он не попадет в коммит.
```bash
$ git commit -am "Commit message"
```

Для того, чтобы переделать последний коммит, нужно внести необходимые изменения, добавьте их в индекс и сделать коммит ещё раз, указав параметр `--amend`:
```bash
$ git commit --amend
$ git commit --amend -m "Modified commit message"
```
Например, если вы сделали коммит и поняли, что забыли проиндексировать изменения в файле, который хотели добавить в коммит, то можно сделать следующее:

```bash
$ git commit -m 'Initial commit'
$ git add forgotten_file
$ git commit --amend
```

В итоге получится единый коммит — второй коммит заменит результаты первого.
Очень важно понимать, что когда вы вносите правки в последний коммит, вы не столько исправляете его, сколько _заменяете_ новым, который полностью его перезаписывает. В результате всё выглядит так, будто первоначальный коммит никогда не существовал, а так же он больше не появится в истории вашего репозитория.
Очевидно, смысл изменения коммитов в добавлении незначительных правок в последние коммиты и, при этом, в избежании засорения истории сообщениями вида «Ой, забыл добавить файл» или «Исправление грамматической ошибки».

### Удаление файлов

Для того чтобы удалить файл из Git, вам необходимо удалить его из отслеживаемых, а затем выполнить коммит. Это позволяет сделать команда `git rm`, которая также удаляет файл из вашего рабочего каталога, так что в следующий раз вы не увидите его как «неотслеживаемый».

```bash
$ git rm <file>
```

Если вы просто удалите файл из своего рабочего каталога, он будет показан в секции `«Changes not staged for commit»`. Затем, если вы выполните команду `git rm`, удаление файла попадёт в индекс и после следующего коммита файл исчезнет и больше не будет отслеживаться.

Если вы изменили файл и уже проиндексировали его, вы должны использовать принудительное удаление c помощью параметра `-f`. Это сделано для повышения безопасности, чтобы предотвратить ошибочное удаление данных, которые ещё не были записаны в снимок состояния и которые нельзя восстановить из Git.

```bash
$ git rm -f <file>
```

Также можно удалить файл из индекса (`staging area`), оставив его при этом в рабочем каталоге (`working tree`). Другими словами, вы можете захотеть оставить файл на жёстком диске, но перестать отслеживать изменения в нём, то есть изменить сотстояние файла на `untracked`.  Это особенно полезно, если вы забыли добавить что-то в файл `.gitignore` и по ошибке проиндексировали, например, большой файл с логами, или кучу промежуточных файлов компиляции. Чтобы сделать это, используйте опцию `--cached`:

```bash
$ git rm --cached <file>
```


### Перемещение и переименовани файлов

Git не отслеживает перемещение файлов явно. Когда вы переименовываете файл в Git, в нём не сохраняется никаких метаданных, говорящих о том, что файл был переименован.  Если просто переименовать `file1` в `file2`, то Git воспримет это как удаление файла `file1` и добавление нового файла `file2`. Тоже самое касается перемещения файла. Для перемещения или переименования файла нужно использовать команду: 

```bash
$ git mv file_from file_to
```

Это эквивалентно выполнению следующих команд:

```bash
$ mv file1 file2
$ git rm file1
$ git add file2
```